#################################################################################################
# Reads from room_aval.json or the json file generated by ems_scraper.py
# Outputs a json file with the room id and the hours it is open
#################################################################################################

import json

def subtract_range(existing_ranges, new_range):
    """
    Takes a list of non-overlapping ranges and subtracts a new range from them.
    
    Args:
        existing_ranges: List of lists, each inner list is [start, end]
        new_range: List containing [start, end]
    
    Returns:
        List of non-overlapping ranges after subtraction
    """
    result = []
    start_new, end_new = new_range

    if start_new == end_new:
        return existing_ranges
    
    for range_item in existing_ranges:
        start, end = range_item
        
        # Case 1: No intersection
        if end_new < start or start_new > end:
            result.append([start, end])
            continue
            
        # Case 2: Current range is split by new range
        if start < start_new and end > end_new:
            result.append([start, start_new])
            result.append([end_new, end])
            continue
            
        # Case 3: Partial overlap at start
        if start < start_new and end > start_new:
            result.append([start, start_new])
            continue
            
        # Case 4: Partial overlap at end
        if start < end_new and end > end_new:
            result.append([end_new, end])
            continue
        
        # Case 5: Complete overlap - skip this range
        continue
    
    # Sort ranges by start time and merge any adjacent ranges
    result.sort(key=lambda x: x[0])
    
    # Merge adjacent or overlapping ranges
    merged = []
    for range_item in result:
        if not merged or merged[-1][1] < range_item[0]:
            merged.append(range_item)
        else:
            merged[-1][1] = max(merged[-1][1], range_item[1])
    
    return merged

def convert_to_time_format(ranges):
    """
    Converts a list of minute ranges into readable time ranges.
    
    Args:
        ranges: List of lists, each inner list contains [start_minute, end_minute]
        where minutes are 0-1440 representing time since midnight
    
    Returns:
        List of formatted time ranges
    """
    def minute_to_time(minutes):
        # Get hours and minutes
        hours = minutes // 60
        mins = minutes % 60
        
        # Determine AM/PM
        period = "AM"
        if hours >= 12:
            period = "PM"
            if hours > 12:
                hours -= 12
        if hours == 0:
            hours = 12
            
        # Format the time with leading zeros if needed
        return f"{hours:02d}:{mins:02d} {period}"
    
    formatted_ranges = []
    for start, end in ranges:
        start_time = minute_to_time(start)
        end_time = minute_to_time(end)
        formatted_ranges.append([start_time, end_time])
    
    return formatted_ranges

def process_room_availability():
    # Read the JSON file
    with open('room_aval.json', 'r') as f:
        room_data = json.load(f)
    
    room_availability = {}
    
    for room_id, room_info in room_data.items():
        # Start with full day availability
        available_ranges = [[0, 1440]]  # 24 hours in minutes
        
        # Process closed hours if they exist
        if 'closed_hours' in room_info:
            closed_start = room_info['closed_hours']['left_position']
            closed_width = room_info['closed_hours']['width']
            closed_end = closed_start + closed_width
            
            # Subtract closed hours from available ranges
            available_ranges = subtract_range(available_ranges, [closed_start, closed_end])

         # Process events if they exist
        if 'events' in room_info:
            for event in room_info['events']:
                # Get event time range using adjusted positions
                event_start = event['adjusted_left']
                event_end = event_start + event['adjusted_width']

                if event_end - event_start >= 1439: 
                    available_ranges = []
                    continue
                
                # Subtract event time from available ranges
                available_ranges = subtract_range(available_ranges, [event_start, event_end])


        
        # Convert available ranges to readable time format
        formatted_ranges = convert_to_time_format(available_ranges)
        
        # Store in result dictionary
        room_availability[room_id] = formatted_ranges
    
    # Write results to new JSON file
    with open('room_availability.json', 'w') as f:
        json.dump(room_availability, f, indent=4)
    
    return room_availability

if __name__ == "__main__":
    availability = process_room_availability()
    
    # Print results
    for room_id, times in availability.items():
        print(f"\nRoom {room_id} is available during:")
        for start, end in times:
            print(f"  {start} - {end}")

    print(len(availability))








